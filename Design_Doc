Group Assignment 2
Group 2
Design Justification

In this document, we will explain in detail how are we satisfying the design goals of this project. Singleton design pattern has been utilized throughout this design to ensure a single instant of our objects to avoid overlapping interactions and control valid  access to system resources.

ease of supporting alternative hardware:

We have moved all of our logical functions and classes into modules outside of our Vending_Manager class. All the functions necessary to access hardware components are only defined in the vending manager. Also, listeners do not have direct access to the logic functions and must go through the Vending_Manager. As a result, in case of any change in hardware, majority of our code including the logical functions, do not need to change, only the methods for hardware access in Vending_Manger and appropriate listeners must be modified.

easy extensibility to other forms of payment, including mixed modes (e.g., paying partially with coins, partially with credit card):

In our manager class, we have an add_credit function that is independent of hardware components. Any form of hardware listener, that accepts payment from the user, can just call this function and report the amount of credit that it has received from the user ( e.g. coins, creditcard, coupons ….). Therefore, if 
a new hardware for payment is added, we just have to implement the listener for that hardware and that listener will use the add_credit function. Same goes for choosing the pop cans as well. 
Our manager.buy(index i) just works with the index of the pop so different hardware modules (e.g. Button, Touchscreen, Voice Recognition, … ) can be used to collect information from the user, the only thing needed is that hardware listeners need to use manager.buy(index i).



ease of changing details on communication with the user and to the event log:

Messaging:
We have a Display_Module class which is in charge of handling user messages and obeys the singleton design pattern. Either it can be used in a cyclical queue mode, which can display several messages sequentially with different durations on repeat and can be interrupted at any state. Or display single messages when needed ( showing user credit for example). 
During runtime or initialization, Vendeing_Manager can easily add or remove messages using the methods of Display_Module class. Please note that Display_Module manages the messages but it does not have direct access to the display hardware and it uses the Vending_Manger methods for that reason. Therefore in case of new display hardware, our Display_module remain intact and only the the hardware interface methods in Vending_Manger need to change. Moreover, In case there be a need to use more than one display in future, the Display_Module object will be in charge of controlling them all.

Logging:
Our log class works in a singleton pattern and the single instant of it is stationed in our Vending_Manger class. 
If any class or method calls the add_log method of vending manager it will  automatically date and time stamp the data and logs it. At this stage we only log a number of hardware listeners that handle user interactions, but, since add_log method is accessible in vending manger we can easily log any other events in the system. 
Also, since we have a singular class for logging, if there be a need to report the logs to perhaps a hardware component or to a different kind of file, it can be done just by adding those methods to the Logging_Module and Vending_Manager should provide the support for the new logging hardware.
 
